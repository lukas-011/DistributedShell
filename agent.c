#include <bits/types/FILE.h>
#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <unistd.h>

#define BUFFER_SMALL 32
#define BUFFER_LARGE 128
#define BUFFER_GINORMOUS 1024
#define PARAM_TESTKEY "testKey"

//TODO: Verify these parameters AND THEIR TYPES
/**
 * The agent will receive the contents of the parallel program, store it on the filesystem, and compile it.
 * @param parallelProg - The parallel program
 * @param contentsOfParallelProg - The contents of the parallel program
 */
void transfer(const char* parallelProg, void* contentsOfParallelProg) {
    printf("'Transfer' API Endpoint\n");
}

//TODO: Verify these parameters AND THEIR TYPES
/**
 * The agent will run the program using the number n as its single argument. Any output of the compiled program will
 * be returned to the distributed shell.
 * @param parallelProg - The parallel program
 * @param n - The argument for the program
 */
void run(const char* parallelProg, const char* n) {
    printf("'Run' API Endpoint\n");
}

/**
 * Test endpoint
 */
 void test(void) {
    printf("Test was hit!\n");
 }

 // Here's an example POST: POST /testWithParams\nHost: Banana\nContent-Type: text/plain\nContent-Length: 4\nkey1=gary&key2=berry&testKey=kacki&key3=fish
 void testWithParams(char* n) {
     printf("Hi I'm %s!\n", n);
 }

 char* parseRequest(const char* request, const char* param) {
     char* line = strstr(request, param);
     char* value = malloc(BUFFER_GINORMOUS);

     // Start param length + 1 for equal sign
     int startingPoint = strlen(param)+1;
     for (int i=startingPoint; i<strlen(line); i++) {
        if (line[i] == '&' || line[i] == '\0' || line[i] == '\n') {
            // We found the end in one form or another so let's break outta here
            break;
        }
        value[i-startingPoint] = line[i];
     }
     return value;
 }

/**
 * Listens for requests and calls the required endpoint.
 * The below code was started with a base generated by ChatGPT
 * as we were told we can use pre-made code from the internet
 * for creating the server. All other code in both the agent
 * and DSH are hand-written by us, including all other methods
 * in this file.
 * @return EXIT_FAILURE if an error occured, or EXIT_SUCCESS if closed gracefully.
 */
int main(void) {
    int server_socket, client_socket;
    struct sockaddr_in server_address, client_address;
    socklen_t client_address_len = sizeof(client_address);
    char buffer[1024];

    // Create socket
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Initialize server_address structure
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(8080);

    // Bind socket
    if (bind(server_socket, (struct sockaddr*) &server_address, sizeof (server_address)) == -1) {
        perror("Socket binding failed");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, 5) == -1) {
        perror("Socket listening failed");
        exit(EXIT_FAILURE);
    }

    // Accept incoming connections
    if ((client_socket = accept(server_socket, (struct sockaddr*)&client_address, &client_address_len)) == -1) {
        perror("Connection acceptance failed");
        exit(EXIT_FAILURE);
    }

    printf("Client connected: %s\n", inet_ntoa(client_address.sin_addr));

    // Receive data from the client
    ssize_t bytes_received;
    while ((bytes_received = recv(client_socket, buffer, 1024, 0)) >0) {
        buffer[bytes_received] = '\0'; // Null-terminate the received data
        printf("Received from client: \n%s", buffer);

        // Check if request is for API endpoint
        if (strstr(buffer, "GET /test") != NULL) {
            test();
        }
        else if (strstr(buffer, "POST /testWithParams")) {
            char* value = parseRequest(strstr(buffer, "POST /testWithParams"),PARAM_TESTKEY);
            testWithParams(value);
        }
    }

    if (bytes_received == -1) {
        perror("Error receiving data");
        exit(EXIT_FAILURE);
    }

    // Close sockets
    close(client_socket);
    close(server_socket);
}
